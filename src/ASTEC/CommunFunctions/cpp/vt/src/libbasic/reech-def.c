/*************************************************************************
 * reech-def.c -
 *
 * $Id: reech-def.begin,v 1.2 2000/10/18 08:45:56 greg Exp $
 *
 * Copyright (c) INRIA 1999
 *
 * AUTHOR:
 * Gregoire Malandain (greg@sophia.inria.fr)
 * 
 * CREATION DATE: 
 *
 *
 * ADDITIONS, CHANGES
 *	
 *	
 *	
 *
 */


/* CAUTION
   DO NOT EDIT THIS FILE,
   UNLESS YOU HAVE A VERY GOOD REASON 
 */


#include <stdio.h>
#include <stdlib.h>

#include <typedefs.h>
#include <chunks.h>

#include <reech-def.h>




#define _CONVERTR_(R) ( R )
#define _CONVERTI_(R) ( (R) >= 0.0 ? ((int)((R)+0.5)) : ((int)((R)-0.5)) )
static int _verbose_ = 1;





void setVerboseInReechDef( int v )
{
  _verbose_ = v;
}

void incrementVerboseInReechDef(  )
{
  _verbose_ ++;
}

void decrementVerboseInReechDef(  )
{
  _verbose_ --;
  if ( _verbose_ < 0 ) _verbose_ = 0;
}





typedef struct {
  void* theBuf; /* buffer to be resampled */
  int *theDim; /* dimensions of this buffer */
  void* resBuf; /* result buffer */
  int *resDim;  /* dimensions of this buffer */
  void** theDef;   /* deformation field */
  int *defDim; /* dimensions of these buffers */
  double* mat_aft;  /* transformation matrix */
  double* mat_bef;  /* transformation matrix */
  float gain;
  float bias;
} _VectorFieldResamplingParam;





static void *_Reech3DTriLinVectorField_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            *rbuf = *tpt;
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r32_u8 ( void* theBuf, /* buffer to be resampled */
                             int *theDim,  /* dimensions of this buffer */
                             void* resBuf, /* result buffer */
                             int *resDim,  /* dimensions of this buffer */
                             r32** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
                             double* mat_aft,  /* transformation matrix */
                             double* mat_bef  /* transformation matrix */
                             )
{
  char *proc = "Reech3DTriLinVectorField_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        res = res * g + b;
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            res = (double)(*tpt) * g + b;
            *rbuf = (u8)_CONVERTI_( res );
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          res = res * g + b;
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          res = res * g + b;
         *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        res = res * g + b;
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          res = res * g + b;
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        res = res * g + b;
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
        *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r32_u8 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r32** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  size_t rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  register u8 *rbuf = (u8*)resBuf;
  
  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;
  
  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;


        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }

        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r32_u8 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r32** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech3DNearestVectorField_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)x + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          *rbuf = *tpt;
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r32_u8 ( void* theBuf, /* buffer to be resampled */
                                                    int *theDim,  /* dimensions of this buffer */
                                                    void* resBuf, /* result buffer */
                                                    int *resDim,  /* dimensions of this buffer */
                                                    r32** theDef, /* deformations */
                                                    int *defDim, /* dimensions of these buffers */
                                                    double* mat_aft,  /* transformation matrix */
                                                    double* mat_bef  /* transformation matrix */
                                                    )
{
  char *proc = "Reech2DTriLinVectorField_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        res = res * g + b;
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          res = (double)(*tpt) * g + b;
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        res = (double)(*tpt) * g + b;
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r32_u8 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r32** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  register u8 *rbuf = (u8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r32_u8 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r32** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech2DNearestVectorField_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            *rbuf = *tpt;
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r32_s8 ( void* theBuf, /* buffer to be resampled */
                             int *theDim,  /* dimensions of this buffer */
                             void* resBuf, /* result buffer */
                             int *resDim,  /* dimensions of this buffer */
                             r32** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
                             double* mat_aft,  /* transformation matrix */
                             double* mat_bef  /* transformation matrix */
                             )
{
  char *proc = "Reech3DTriLinVectorField_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        res = res * g + b;
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            res = (double)(*tpt) * g + b;
            *rbuf = (s8)_CONVERTI_( res );
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          res = res * g + b;
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          res = res * g + b;
         *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        res = res * g + b;
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          res = res * g + b;
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        res = res * g + b;
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
        *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r32_s8 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r32** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  size_t rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  register s8 *rbuf = (s8*)resBuf;
  
  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;
  
  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;


        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }

        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r32_s8 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r32** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech3DNearestVectorField_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)x + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          *rbuf = *tpt;
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r32_s8 ( void* theBuf, /* buffer to be resampled */
                                                    int *theDim,  /* dimensions of this buffer */
                                                    void* resBuf, /* result buffer */
                                                    int *resDim,  /* dimensions of this buffer */
                                                    r32** theDef, /* deformations */
                                                    int *defDim, /* dimensions of these buffers */
                                                    double* mat_aft,  /* transformation matrix */
                                                    double* mat_bef  /* transformation matrix */
                                                    )
{
  char *proc = "Reech2DTriLinVectorField_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        res = res * g + b;
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          res = (double)(*tpt) * g + b;
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        res = (double)(*tpt) * g + b;
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r32_s8 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r32** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  register s8 *rbuf = (s8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r32_s8 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r32** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech2DNearestVectorField_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            *rbuf = *tpt;
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r32_u16 ( void* theBuf, /* buffer to be resampled */
                             int *theDim,  /* dimensions of this buffer */
                             void* resBuf, /* result buffer */
                             int *resDim,  /* dimensions of this buffer */
                             r32** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
                             double* mat_aft,  /* transformation matrix */
                             double* mat_bef  /* transformation matrix */
                             )
{
  char *proc = "Reech3DTriLinVectorField_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        res = res * g + b;
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            res = (double)(*tpt) * g + b;
            *rbuf = (u16)_CONVERTI_( res );
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          res = res * g + b;
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          res = res * g + b;
         *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        res = res * g + b;
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          res = res * g + b;
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        res = res * g + b;
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
        *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r32_u16 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r32** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  size_t rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  register u16 *rbuf = (u16*)resBuf;
  
  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;
  
  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;


        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }

        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r32_u16 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r32** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech3DNearestVectorField_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)x + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          *rbuf = *tpt;
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r32_u16 ( void* theBuf, /* buffer to be resampled */
                                                    int *theDim,  /* dimensions of this buffer */
                                                    void* resBuf, /* result buffer */
                                                    int *resDim,  /* dimensions of this buffer */
                                                    r32** theDef, /* deformations */
                                                    int *defDim, /* dimensions of these buffers */
                                                    double* mat_aft,  /* transformation matrix */
                                                    double* mat_bef  /* transformation matrix */
                                                    )
{
  char *proc = "Reech2DTriLinVectorField_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        res = res * g + b;
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          res = (double)(*tpt) * g + b;
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        res = (double)(*tpt) * g + b;
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r32_u16 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r32** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  register u16 *rbuf = (u16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r32_u16 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r32** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech2DNearestVectorField_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            *rbuf = *tpt;
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r32_s16 ( void* theBuf, /* buffer to be resampled */
                             int *theDim,  /* dimensions of this buffer */
                             void* resBuf, /* result buffer */
                             int *resDim,  /* dimensions of this buffer */
                             r32** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
                             double* mat_aft,  /* transformation matrix */
                             double* mat_bef  /* transformation matrix */
                             )
{
  char *proc = "Reech3DTriLinVectorField_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        res = res * g + b;
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            res = (double)(*tpt) * g + b;
            *rbuf = (s16)_CONVERTI_( res );
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          res = res * g + b;
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          res = res * g + b;
         *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        res = res * g + b;
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          res = res * g + b;
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        res = res * g + b;
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
        *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r32_s16 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r32** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  size_t rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  register s16 *rbuf = (s16*)resBuf;
  
  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;
  
  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;


        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }

        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r32_s16 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r32** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech3DNearestVectorField_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)x + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          *rbuf = *tpt;
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r32_s16 ( void* theBuf, /* buffer to be resampled */
                                                    int *theDim,  /* dimensions of this buffer */
                                                    void* resBuf, /* result buffer */
                                                    int *resDim,  /* dimensions of this buffer */
                                                    r32** theDef, /* deformations */
                                                    int *defDim, /* dimensions of these buffers */
                                                    double* mat_aft,  /* transformation matrix */
                                                    double* mat_bef  /* transformation matrix */
                                                    )
{
  char *proc = "Reech2DTriLinVectorField_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        res = res * g + b;
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          res = (double)(*tpt) * g + b;
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        res = (double)(*tpt) * g + b;
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r32_s16 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r32** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  register s16 *rbuf = (s16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r32_s16 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r32** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech2DNearestVectorField_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            *rbuf = *tpt;
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r32_r32 ( void* theBuf, /* buffer to be resampled */
                             int *theDim,  /* dimensions of this buffer */
                             void* resBuf, /* result buffer */
                             int *resDim,  /* dimensions of this buffer */
                             r32** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
                             double* mat_aft,  /* transformation matrix */
                             double* mat_bef  /* transformation matrix */
                             )
{
  char *proc = "Reech3DTriLinVectorField_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        res = res * g + b;
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            res = (double)(*tpt) * g + b;
            *rbuf = (r32)_CONVERTR_( res );
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          res = res * g + b;
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          res = res * g + b;
         *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        res = res * g + b;
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          res = res * g + b;
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        res = res * g + b;
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
        *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r32_r32 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r32** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  size_t rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  register r32 *rbuf = (r32*)resBuf;
  
  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;
  
  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;


        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }

        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r32_r32 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r32** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech3DNearestVectorField_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)x + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          *rbuf = *tpt;
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r32_r32 ( void* theBuf, /* buffer to be resampled */
                                                    int *theDim,  /* dimensions of this buffer */
                                                    void* resBuf, /* result buffer */
                                                    int *resDim,  /* dimensions of this buffer */
                                                    r32** theDef, /* deformations */
                                                    int *defDim, /* dimensions of these buffers */
                                                    double* mat_aft,  /* transformation matrix */
                                                    double* mat_bef  /* transformation matrix */
                                                    )
{
  char *proc = "Reech2DTriLinVectorField_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        res = res * g + b;
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          res = (double)(*tpt) * g + b;
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        res = (double)(*tpt) * g + b;
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r32_r32 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r32** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  register r32 *rbuf = (r32*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r32_r32 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r32** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech2DNearestVectorField_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            *rbuf = *tpt;
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r64_u8 ( void* theBuf, /* buffer to be resampled */
                             int *theDim,  /* dimensions of this buffer */
                             void* resBuf, /* result buffer */
                             int *resDim,  /* dimensions of this buffer */
                             r64** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
                             double* mat_aft,  /* transformation matrix */
                             double* mat_bef  /* transformation matrix */
                             )
{
  char *proc = "Reech3DTriLinVectorField_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        res = res * g + b;
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            res = (double)(*tpt) * g + b;
            *rbuf = (u8)_CONVERTI_( res );
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          res = res * g + b;
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          res = res * g + b;
         *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        res = res * g + b;
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          res = res * g + b;
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        res = res * g + b;
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
        *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r64_u8 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r64** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  size_t rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  register u8 *rbuf = (u8*)resBuf;
  
  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;
  
  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;


        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }

        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r64_u8 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r64** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech3DNearestVectorField_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)x + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          *rbuf = *tpt;
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r64_u8 ( void* theBuf, /* buffer to be resampled */
                                                    int *theDim,  /* dimensions of this buffer */
                                                    void* resBuf, /* result buffer */
                                                    int *resDim,  /* dimensions of this buffer */
                                                    r64** theDef, /* deformations */
                                                    int *defDim, /* dimensions of these buffers */
                                                    double* mat_aft,  /* transformation matrix */
                                                    double* mat_bef  /* transformation matrix */
                                                    )
{
  char *proc = "Reech2DTriLinVectorField_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        res = res * g + b;
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          res = (double)(*tpt) * g + b;
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        res = (double)(*tpt) * g + b;
        *rbuf = (u8)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r64_u8 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r64** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  register u8 *rbuf = (u8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r64_u8 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r64** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech2DNearestVectorField_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            *rbuf = *tpt;
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r64_s8 ( void* theBuf, /* buffer to be resampled */
                             int *theDim,  /* dimensions of this buffer */
                             void* resBuf, /* result buffer */
                             int *resDim,  /* dimensions of this buffer */
                             r64** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
                             double* mat_aft,  /* transformation matrix */
                             double* mat_bef  /* transformation matrix */
                             )
{
  char *proc = "Reech3DTriLinVectorField_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        res = res * g + b;
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            res = (double)(*tpt) * g + b;
            *rbuf = (s8)_CONVERTI_( res );
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          res = res * g + b;
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          res = res * g + b;
         *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        res = res * g + b;
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          res = res * g + b;
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        res = res * g + b;
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
        *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r64_s8 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r64** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  size_t rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  register s8 *rbuf = (s8*)resBuf;
  
  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;
  
  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;


        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }

        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r64_s8 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r64** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech3DNearestVectorField_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)x + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          *rbuf = *tpt;
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r64_s8 ( void* theBuf, /* buffer to be resampled */
                                                    int *theDim,  /* dimensions of this buffer */
                                                    void* resBuf, /* result buffer */
                                                    int *resDim,  /* dimensions of this buffer */
                                                    r64** theDef, /* deformations */
                                                    int *defDim, /* dimensions of these buffers */
                                                    double* mat_aft,  /* transformation matrix */
                                                    double* mat_bef  /* transformation matrix */
                                                    )
{
  char *proc = "Reech2DTriLinVectorField_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        res = res * g + b;
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          res = (double)(*tpt) * g + b;
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        res = (double)(*tpt) * g + b;
        *rbuf = (s8)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r64_s8 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r64** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  register s8 *rbuf = (s8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r64_s8 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r64** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech2DNearestVectorField_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            *rbuf = *tpt;
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r64_u16 ( void* theBuf, /* buffer to be resampled */
                             int *theDim,  /* dimensions of this buffer */
                             void* resBuf, /* result buffer */
                             int *resDim,  /* dimensions of this buffer */
                             r64** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
                             double* mat_aft,  /* transformation matrix */
                             double* mat_bef  /* transformation matrix */
                             )
{
  char *proc = "Reech3DTriLinVectorField_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        res = res * g + b;
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            res = (double)(*tpt) * g + b;
            *rbuf = (u16)_CONVERTI_( res );
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          res = res * g + b;
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          res = res * g + b;
         *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        res = res * g + b;
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          res = res * g + b;
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        res = res * g + b;
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
        *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r64_u16 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r64** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  size_t rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  register u16 *rbuf = (u16*)resBuf;
  
  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;
  
  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;


        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }

        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r64_u16 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r64** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech3DNearestVectorField_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)x + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          *rbuf = *tpt;
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r64_u16 ( void* theBuf, /* buffer to be resampled */
                                                    int *theDim,  /* dimensions of this buffer */
                                                    void* resBuf, /* result buffer */
                                                    int *resDim,  /* dimensions of this buffer */
                                                    r64** theDef, /* deformations */
                                                    int *defDim, /* dimensions of these buffers */
                                                    double* mat_aft,  /* transformation matrix */
                                                    double* mat_bef  /* transformation matrix */
                                                    )
{
  char *proc = "Reech2DTriLinVectorField_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        res = res * g + b;
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          res = (double)(*tpt) * g + b;
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        res = (double)(*tpt) * g + b;
        *rbuf = (u16)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r64_u16 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r64** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  register u16 *rbuf = (u16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r64_u16 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r64** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech2DNearestVectorField_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            *rbuf = *tpt;
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r64_s16 ( void* theBuf, /* buffer to be resampled */
                             int *theDim,  /* dimensions of this buffer */
                             void* resBuf, /* result buffer */
                             int *resDim,  /* dimensions of this buffer */
                             r64** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
                             double* mat_aft,  /* transformation matrix */
                             double* mat_bef  /* transformation matrix */
                             )
{
  char *proc = "Reech3DTriLinVectorField_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        res = res * g + b;
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            res = (double)(*tpt) * g + b;
            *rbuf = (s16)_CONVERTI_( res );
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          res = res * g + b;
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          res = res * g + b;
         *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        res = res * g + b;
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          res = res * g + b;
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        res = res * g + b;
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
        *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r64_s16 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r64** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  size_t rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  register s16 *rbuf = (s16*)resBuf;
  
  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;
  
  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;


        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }

        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r64_s16 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r64** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech3DNearestVectorField_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)x + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          *rbuf = *tpt;
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r64_s16 ( void* theBuf, /* buffer to be resampled */
                                                    int *theDim,  /* dimensions of this buffer */
                                                    void* resBuf, /* result buffer */
                                                    int *resDim,  /* dimensions of this buffer */
                                                    r64** theDef, /* deformations */
                                                    int *defDim, /* dimensions of these buffers */
                                                    double* mat_aft,  /* transformation matrix */
                                                    double* mat_bef  /* transformation matrix */
                                                    )
{
  char *proc = "Reech2DTriLinVectorField_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        res = res * g + b;
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          res = (double)(*tpt) * g + b;
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        res = (double)(*tpt) * g + b;
        *rbuf = (s16)_CONVERTI_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r64_s16 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r64** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  register s16 *rbuf = (s16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r64_s16 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r64** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech2DNearestVectorField_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            *rbuf = *tpt;
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r64_r32 ( void* theBuf, /* buffer to be resampled */
                             int *theDim,  /* dimensions of this buffer */
                             void* resBuf, /* result buffer */
                             int *resDim,  /* dimensions of this buffer */
                             r64** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
                             double* mat_aft,  /* transformation matrix */
                             double* mat_bef  /* transformation matrix */
                             )
{
  char *proc = "Reech3DTriLinVectorField_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy + (size_t)doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) &&
           (z > 0.0) && (iz < t1dimz) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dz = z - iz;
        dxdy = dx*dy;
        dxdz = dx*dz;
        dydz = dy*dz;
        dxdydz = dxdy*dz;

        /* we have
           v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
           v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
           v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
           v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
           v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
           v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy + (size_t)toffset1;
        v6 = dxdz-dxdydz;
        v5 = dxdy-dxdydz;
        v4 = dx-dxdy-v6;

        res = 0;
        res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
        tpt --;
        res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
        tpt -= t1dimx;
        res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
        tpt --;
        res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
        tpt -= toffset2;
        res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        tpt --;
        res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt -= t1dimx;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt --;
        res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        res = res * g + b;
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
        if ( (y < 0.0) || (iy == t1dimy) ) {
          if ( (z < 0.0) || (iz == t1dimz) ) {
            res = (double)(*tpt) * g + b;
            *rbuf = (r32)_CONVERTR_( res );
            continue;
          }
          dz = z - iz;
          res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
          tpt += tdimxy;
          res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
          res = res * g + b;
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dy = y - iy;
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
          tpt += tdimx;
          res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
          res = res * g + b;
         *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt += tdimx;
        res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
        tpt += toffset2+1;
        res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt += tdimx;
        res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
        res = res * g + b;
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here we are sure that the border is either
         along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
        if ( (z < 0.0) || (iz == t1dimz) ) {
          res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
          tpt ++;
          res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
          res = res * g + b;
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dz = z - iz;
        res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
        tpt ++;
        res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
        tpt += tdimxy-1;
        res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
        tpt ++;
        res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
        res = res * g + b;
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
        *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r64_r32 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r64** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  size_t rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  register r32 *rbuf = (r32*)resBuf;
  
  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;
  
  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        zd = (double)k + *defz;
        defx ++;
        defy ++;
        defz ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
        z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;
        iz = (int)z;


        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5)
             || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) &&
             (z > 0.0) && (iz < d1dimz) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dz = z - iz;
          dxdy = dx*dy;
          dxdz = dx*dz;
          dydz = dy*dz;
          dxdydz = dxdy*dz;

          /* we have
             v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
             v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
             v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
             v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
             v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
             v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v6 = dxdz-dxdydz;
          v5 = dxdy-dxdydz;
          v4 = dx-dxdy-v6;

          for ( l=0; l<3; l++ ) {
            v[l] = 0;
            dbuf = theDef[l];
            dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
            v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
            dbuf --;
            v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
            dbuf -= d1dimx;
            v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
            dbuf --;
            v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
            dbuf -= doffset2;
            v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
            dbuf --;
            v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf -= d1dimx;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf --;
            v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
          }

        }
        else {

          /* here, we are sure we are on some border */

          if ( (x < 0.0) || (ix == d1dimx) ) {
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = *dbuf;
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
                  dbuf += ddimxy;
                  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf += ddimx;
                  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                  dbuf += doffset2+1;
                  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf += ddimx;
                  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
                }
              }
            }
          }
          else {
            /* here we are sure that the border is either
               along the Y or the Z axis */
            dx = x - ix;
            if ( (y < 0.0) || (iy == d1dimy) ) {
              if ( (z < 0.0) || (iz == d1dimz) ) {
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                }
              }
              else {
                dz = z - iz;
                for ( l=0; l<3; l++ ) {
                  v[l] = 0;
                  dbuf = theDef[l];
                  dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
                  dbuf ++;
                  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                  dbuf += ddimxy-1;
                  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
                  dbuf ++;
                  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
                }
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<3; l++ ) {
                v[l] = 0;
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)iz * (size_t)ddimxy;
                v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
                dbuf ++;
                v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
                dbuf += d1dimx;
                v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
                dbuf ++;
                v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
              }
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];
        zd = z + v[2];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = zd;
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
        z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
        if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)iz * (size_t)tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r64_r32 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r64** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech3DNearestVectorField_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)x + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          *rbuf = *tpt;
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r64_r32 ( void* theBuf, /* buffer to be resampled */
                                                    int *theDim,  /* dimensions of this buffer */
                                                    void* resBuf, /* result buffer */
                                                    int *resDim,  /* dimensions of this buffer */
                                                    r64** theDef, /* deformations */
                                                    int *defDim, /* dimensions of these buffers */
                                                    double* mat_aft,  /* transformation matrix */
                                                    double* mat_bef  /* transformation matrix */
                                                    )
{
  char *proc = "Reech2DTriLinVectorField_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
           (y > 0.0) && (iy < t1dimy) ) {
        /* the corresponding point is in the box defined
           by (ix[+1],iy[+1],iz[+1]) */
        dx = x - ix;
        dy = y - iy;
        dxdy = dx*dy;

        /* we have
           v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
           v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
           v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
           v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
        */
        tpt += (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy;

        v1 = dy-dxdy;
        v4 = dx-dxdy;

        res = 0;
        res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
        tpt ++;
        res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
        tpt += t1dimx;
        res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
        tpt ++;
        res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
        res = res * g + b;
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
        /* we just look at y */
        if ( (y < 0.0) || (iy == t1dimy) ) {
          res = (double)(*tpt) * g + b;
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        dy = y - iy;
        res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
        tpt += tdimx;
        res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
        res = (double)(*tpt) * g + b;
        *rbuf = (r32)_CONVERTR_( res );
        continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r64_r32 ( void* theBuf, /* buffer to be resampled */
                                                      int *theDim,  /* dimensions of this buffer */
                                                      void* resBuf, /* result buffer */
                                                      int *resDim,  /* dimensions of this buffer */
                                                      r64** theDef, /* deformations */
                                                      int *defDim, /* dimensions of these buffers */
                                                      double* mat_aft,  /* transformation matrix */
                                                      double* mat_bef,  /* transformation matrix */
                                                      float gain,
                                                      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  size_t i, j, k;
  int l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  size_t rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  register r32 *rbuf = (r32*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
        xd = (double)i + *defx;
        yd = (double)j + *defy;
        defx ++;
        defy ++;
      }
      else {

        /* apply the first matrix */
        x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
        y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];

        /* interpolate the vector deformation at (xd,yd,zd) */
        ix = (int)x;
        iy = (int)y;

        /* the point is outside the deformation field
         */
        if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
             || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
          *rbuf = 0;
          continue;
        }

        /* vector interpolation: are we on the border or not ? */
        if ( (x > 0.0) && (ix < d1dimx) &&
             (y > 0.0) && (iy < d1dimy) ) {
          /* the corresponding point is in the box defined
             by (ix[+1],iy[+1],iz[+1]) */
          dx = x - ix;
          dy = y - iy;
          dxdy = dx*dy;

          /* we have
             v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
             v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
             v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
             v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
          */

          v1 = dy-dxdy;
          v4 = dx-dxdy;

          for ( l=0; l<2; l++ ) {
            dbuf = theDef[l];
            dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
            v[l] = 0;
            v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
            dbuf ++;
            v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
            dbuf += d1dimx;
            v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
            dbuf ++;
            v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
          }
        }
        else {

          /* here, we are sure we are on some border */
          if ( (x < 0.0) || (ix == d1dimx) ) {

            /* we just look at y */
            if ( (y < 0.0) || (iy == d1dimy) ) {
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l] = *dbuf;
              }
            }
            else {
              dy = y - iy;
              for ( l=0; l<2; l++ ) {
                dbuf = theDef[l];
                dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
                v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
                dbuf += d1dimx;
                v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
              }
            }
          }
          else {
            dx = x - ix;
            for ( l=0; l<2; l++ ) {
              dbuf = theDef[l];
              dbuf += (size_t)ix + (size_t)iy * (size_t)ddimx + (size_t)k * (size_t)ddimxy;
              v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
              dbuf ++;
              v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
            }
          }
        }

        xd = x + v[0];
        yd = y + v[1];

      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
        x = xd;
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = yd;
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
        x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
        if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
        y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
        if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
         the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ (size_t)ix + (size_t)iy * (size_t)tdimx + (size_t)k * (size_t)tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r64_r32 ( void* theBuf, /* buffer to be resampled */
                                                     int *theDim,  /* dimensions of this buffer */
                                                     void* resBuf, /* result buffer */
                                                     int *resDim,  /* dimensions of this buffer */
                                                     r64** theDef, /* deformations */
                                                     int *defDim, /* dimensions of these buffers */
                                                     double* mat_aft,  /* transformation matrix */
                                                     double* mat_bef  /* transformation matrix */
                                                     )
{
  char *proc = "Reech2DNearestVectorField_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
        fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}
