/*************************************************************************
 * reech4x4.c -
 *
 * $Id: reech4x4.begin,v 1.3 2001/12/10 08:45:17 greg Exp $
 *
 * Copyright (c) INRIA 1999
 *
 * AUTHOR:
 * Gregoire Malandain (greg@sophia.inria.fr)
 * 
 * CREATION DATE: 
 *
 *
 * ADDITIONS, CHANGES
 *	
 *	
 *	
 *
 */


/* CAUTION
   DO NOT EDIT THIS FILE,
   UNLESS YOU HAVE A VERY GOOD REASON 
 */

#include <stdio.h>
#include <stdlib.h>

#include <typedefs.h>
#include <chunks.h>

#include <cspline.h>
#include <cspline4x4.h>



#define _CONVERTR_(R) ( R )
#define _CONVERTI_(R) ( (R) >= 0.0 ? ((int)((R)+0.5)) : ((int)((R)-0.5)) )
static int _verbose_ = 1;




void setVerboseInCspline4x4( int v )
{
  _verbose_ = v;
}

void incrementVerboseInCspline4x4(  )
{
  _verbose_ ++;
}

void decrementVerboseInCspline4x4(  )
{
  _verbose_ --;
  if ( _verbose_ < 0 ) _verbose_ = 0;
}





/* Fonctions pour l'interpolation spline cubique.
   A. Roche
*/


/* Cette fonction renvoie la valeur de la fonction B-spline
   cubique elementaire en x */

static double CubicBspline ( double x )
{
  double aux;

  if ( x >= 0.0 ) {
    if ( x >=  2.0 ) return( 0.0 );
    if ( x < 1 ) {
      aux = x*x;
      return( (double)2.0/(double)3.0 - aux + (double)0.5*aux*x );
    }
    aux = 2.0 - x;
    return( aux*aux*aux/(double)6.0 );
  }

  /* ici x < 0
   */
  if ( x <= -2.0 ) return( 0.0 );
  if ( x > -1 ) {
    aux = x*x;
    return( (double)2.0/(double)3.0 - aux - (double)0.5*aux*x );
  }
  aux = 2.0 + x;
  return( aux*aux*aux/(double)6.0 );
}





static double CubicBspline_FirstDeriv ( double x )
{
  if ( x == 0.0 ) return( 0.0 );

  if ( x > 0.0 ) {
    if ( x >=  2.0 ) return( 0.0 );
    if ( x < 1 ) {
      return( (-2.0 + 1.5*x)*x );
    }
    return( -0.5 * (2.0-x) * (2.0-x) );
  }

  /* ici x < 0
   */
  if ( x <= -2.0 ) return( 0.0 );
  if ( x > -1 ) {
    return( (-2.0 - 1.5*x)*x );
  }
  return( 0.5 * (2.0+x) * (2.0+x) );
}




static double CubicBspline_SecndDeriv ( double x )
{
  if ( x > 0.0 ) {
    if ( x >=  2.0 ) return( 0.0 );
    if ( x < 1 ) {
      return( -2.0 + 3.0*x );
    }
    return( 2.0 - x );
  }

  /* ici x < 0
   */
  if ( x <= -2.0 ) return( 0.0 );
  if ( x > -1 ) {
    return( -2.0 - 3.0*x );
  }
  return( 2.0 + x );
}





typedef struct {
  typeCSplineCoefficients *theCoeff; /* cspline coefficients */
  void* resBuf; /* result buffer */
  int *resDim;  /* dimensions of this buffer */
  double* mat;  /* transformation matrix */
  int* derivative; /* derivative orders */
  float gain;
  float bias;
} _CsplineResamplingParam;





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.
   
   (double* mat) is the matrix which permits to get
   from resBuf into theBuf. 
   If one only have the matrix from theBuf into resBuf,
   it must be inverted first.

   Soit x le point transforme et ix=(int)x;
   nous allons distinguer les cas suivants :
    x < -0.5               => resultat = 0
    -0.5 <= x < 0.0        => ix=0, on n'interpole pas selon X
    0.0 < x && ix < dimx-1 => on interpole selon X
    x < dimx-0.5           => ix=dimx-1, on n'interpole pas selon X
    x >= dimx-0.5          => resultat = 0

*/

static void *_Cspline3D4x4_u8 ( void *par )
{
  char *proc = "_Cspline3D4x4_u8";
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _CsplineResamplingParam *p = (_CsplineResamplingParam *)parameter;
  
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat; 
  int *derivative = p->derivative;
  typeCSplineCoefficients *theCoeff = p->theCoeff;

  size_t i, j, k;
  register int ix, iy, iz;
  register double x, y, z, dx, dy, dz;
  register double res;
  size_t rdimx=resDim[0], rdimy=resDim[1];

  register u8 *rbuf = (u8*)resBuf;

  register float *tbuf;
  float *bufCoeff = theCoeff->theCoeff;

  int tdimx  = theCoeff->theDim[0];
  int tdimxy = theCoeff->theDim[0] * theCoeff->theDim[1];

  int tdimx3 = theCoeff->theDim[0]-3;
  int tdimy3 = theCoeff->theDim[1]-3;
  int tdimz3 = theCoeff->theDim[2]-3;

  register double ddimx = (double)theCoeff->theDim[0]-2.0-0.5;
  register double ddimy = (double)theCoeff->theDim[1]-2.0-0.5;
  register double ddimz = (double)theCoeff->theDim[2]-2.0-0.5;

  double cx[4], cy[4], cz[4], cyz;
  size_t offset[64];

  int l, m, n, o;

  double (*bsplinx)(double);
  double (*bspliny)(double);
  double (*bsplinz)(double);

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;
  size_t iend, jend;



  if ( derivative == (int*) NULL ) {
    bsplinx = & CubicBspline;
    bspliny = & CubicBspline;
    bsplinz = & CubicBspline;
  } else {
    switch ( derivative[0] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in x\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bsplinx = & CubicBspline;            break;
    case 1 : bsplinx = & CubicBspline_FirstDeriv; break;
    case 2 : bsplinx = & CubicBspline_SecndDeriv; break;
    }

    switch ( derivative[1] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in y\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bspliny = & CubicBspline;            break;
    case 1 : bspliny = & CubicBspline_FirstDeriv; break;
    case 2 : bspliny = & CubicBspline_SecndDeriv; break;
    }

    switch ( derivative[2] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in z\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bsplinz = & CubicBspline;            break;
    case 1 : bsplinz = & CubicBspline_FirstDeriv; break;
    case 2 : bsplinz = & CubicBspline_SecndDeriv; break;
    }
  }



  for ( o = 0, l = 0; l < 4; l ++ )
  for ( m = 0; m < 4; m ++ )
  for ( n = 0; n < 4; n ++, o ++ ) {
    offset[o] = (size_t)l * (size_t)tdimxy + (size_t)m * (size_t)tdimx + (size_t)n;
  }



  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
        /* computation of the corresponding point after deformation

           (x,y,x) -> (ix=(int)x,iy=(int)x,iz=(int)x)
           les coefficients de la spline a prendre en compte
           sont [1+ix+{-1,0,1,2}, 1+iy+{-1,0,1,2}, 1+iz+{-1,0,1,2}]

           On ajoute 1 aux coordonnees, car on a ajoute
           une bordure aux coefficients de la spline.
         */

	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }
	
        /* ici on a 0 <   x   < theCoeff->theDim[0]-3
                    0 <= ix   < theCoeff->theDim[0]-3
                    1 <= ix+1 < theCoeff->theDim[0]-2
                    0 <= ix+1-1 && ix+1+2 < theCoeff->theDim[0]

           maintenant on a -0.5 <         x   <        theCoeff->theDim[0]-2.5
                              0 <= ix   <= theCoeff->theDim[0]-3
                              1 <= ix+1 <= theCoeff->theDim[0]-2

           les extrema pour les coefficients verifient
                              0 <= ix+1-1 <= theCoeff->theDim[0]-3
                              3 <= ix+1+2 <= theCoeff->theDim[0]
           dans ce dernier cas, on suppose que ca va etre 0 ...
        */
        ix = (int)x;    dx = x-ix;
        iy = (int)y;    dy = y-iy;
        iz = (int)z;    dz = z-iz;

        if ( x < 0.0 ) { x = 0.0; ix = 0; dx = 0.0; }
        if ( y < 0.0 ) { y = 0.0; iy = 0; dy = 0.0; }
        if ( z < 0.0 ) { z = 0.0; iz = 0; dz = 0.0; }

        /* Pre-calcul des valeurs de bsplines pour chaque dimension:

           (*bsplinx)(dx-1), (*bsplinx)(dx), (*bsplinx)(dx+1), (*bsplinx)(dx+2)
           (*bspliny)(dy-1), (*bspliny)(dy), (*bspliny)(dy+1), (*bspliny)(dy+2)
           (*bsplinz)(dz-1), (*bsplinz)(dz), (*bsplinz)(dz+1), (*bsplinz)(dz+2)

           A. Roche

           Dans l'image des coefficients,
           (*bsplinx)(dx-1) correspond a ix,
           (*bsplinx)(dy-1) correspond a iy,
           (*bsplinx)(dz-1) correspond a iz,

        */
        for ( l = 0; l < 4; l ++ ) {
          cx[l] = (*bsplinx)( dx - (double)(l-1) );
          cy[l] = (*bspliny)( dy - (double)(l-1) );
          cz[l] = (*bsplinz)( dz - (double)(l-1) );
        }

        tbuf = bufCoeff;
        tbuf += (size_t)iz * (size_t)tdimxy + (size_t)iy * (size_t)tdimx + (size_t)ix;



        /*
         * are we on the border or not ?
         */
        if ( (ix < tdimx3) && (iy < tdimy3) && (iz < tdimz3) ) {


          for ( res = 0.0, o = 0, l = 0; l < 4; l ++ )
          for ( m = 0; m < 4; m ++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ ) {
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
          }
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }

        /*
         * here, we are sure we are on some border
         * if ix == tdimx3  => ix = theCoeff->theDim[0]-3
         */

        *rbuf = 0;
        *rbuf = (u8)_CONVERTI_( 0 );

        if ( ix == tdimx3 ) {
          if ( iy == tdimy3 ) {
            if ( iz == tdimz3 ) {

              for ( res = 0.0, o = 0, l = 0; l < 3; l++, o+=4 )
              for ( m = 0; m < 3; m++, o++ ) {
                cyz = cz[l]*cy[m];
                for ( n = 0; n < 3; n ++, o ++ )
                  res += cx[n]*cyz*tbuf[ offset[ o ] ];
              }
              *rbuf = (u8)_CONVERTI_( res );
              continue;
            }
            for ( res = 0.0, o = 0, l = 0; l < 4; l++, o+=4 )
            for ( m = 0; m < 3; m++, o++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 3; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (u8)_CONVERTI_( res );
            continue;
          }

          if ( iz == tdimz3 ) {
            for ( res = 0.0, o = 0, l = 0; l < 3; l++ )
            for ( m = 0; m < 4; m++, o++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 3; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (u8)_CONVERTI_( res );
            continue;
          }
          for ( res = 0.0, o = 0, l = 0; l < 4; l++ )
          for ( m = 0; m < 4; m++, o++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 3; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (u8)_CONVERTI_( res );
          continue;

        }

        if ( iy == tdimy3 ) {

          if ( iz == tdimz3 ) {
            for ( res = 0.0, o = 0, l = 0; l < 3; l++, o+=4 )
            for ( m = 0; m < 3; m++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 4; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (u8)_CONVERTI_( res );
            continue;
          }
          for ( res = 0.0, o = 0, l = 0; l < 4; l++, o+=4 )
          for ( m = 0; m < 3; m++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (u8)_CONVERTI_( res );
          continue;

        }

        if ( iz == tdimz3 ) {
          for ( res = 0.0, o = 0, l = 0; l < 3; l++ )
          for ( m = 0; m < 4; m++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (u8)_CONVERTI_( res );
          continue;
        }
        for ( res = 0.0, o = 0, l = 0; l < 4; l++ )
        for ( m = 0; m < 4; m++ ) {
          cyz = cz[l]*cy[m];
          for ( n = 0; n < 4; n ++, o ++ )
            res += cx[n]*cyz*tbuf[ offset[ o ] ];
        }
        *rbuf = (u8)_CONVERTI_( res );
        continue;

      }
    }
  }

  chunk->ret = 1;
  return( (void*)NULL );
}





int Cspline3D4x4_u8 ( typeCSplineCoefficients *theCoeff,
                         void* resBuf, /* result buffer */
                         int *resDim,  /* dimensions of this buffer */
                         double* mat,   /* transformation matrix */
                         int *derivative
                         )
{
  char *proc = "Cspline3D4x4_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _CsplineResamplingParam p;
  
  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return( -1 );
  }
  
  p.theCoeff = theCoeff;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.derivative = derivative;
  p.gain = 1.0;
  p.bias = 0.0;
  
  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Cspline3D4x4_u8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return( -1 );
  }
  
  freeChunks( &chunks );
  return( 1 );
}








/* Resampling procedure.

   Work for 3D images, not for vectorial ones.
   
   (double* mat) is the matrix which permits to get
   from resBuf into theBuf. 
   If one only have the matrix from theBuf into resBuf,
   it must be inverted first.

   Soit x le point transforme et ix=(int)x;
   nous allons distinguer les cas suivants :
    x < -0.5               => resultat = 0
    -0.5 <= x < 0.0        => ix=0, on n'interpole pas selon X
    0.0 < x && ix < dimx-1 => on interpole selon X
    x < dimx-0.5           => ix=dimx-1, on n'interpole pas selon X
    x >= dimx-0.5          => resultat = 0

*/

static void *_Cspline3D4x4_s8 ( void *par )
{
  char *proc = "_Cspline3D4x4_s8";
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _CsplineResamplingParam *p = (_CsplineResamplingParam *)parameter;
  
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat; 
  int *derivative = p->derivative;
  typeCSplineCoefficients *theCoeff = p->theCoeff;

  size_t i, j, k;
  register int ix, iy, iz;
  register double x, y, z, dx, dy, dz;
  register double res;
  size_t rdimx=resDim[0], rdimy=resDim[1];

  register s8 *rbuf = (s8*)resBuf;

  register float *tbuf;
  float *bufCoeff = theCoeff->theCoeff;

  int tdimx  = theCoeff->theDim[0];
  int tdimxy = theCoeff->theDim[0] * theCoeff->theDim[1];

  int tdimx3 = theCoeff->theDim[0]-3;
  int tdimy3 = theCoeff->theDim[1]-3;
  int tdimz3 = theCoeff->theDim[2]-3;

  register double ddimx = (double)theCoeff->theDim[0]-2.0-0.5;
  register double ddimy = (double)theCoeff->theDim[1]-2.0-0.5;
  register double ddimz = (double)theCoeff->theDim[2]-2.0-0.5;

  double cx[4], cy[4], cz[4], cyz;
  size_t offset[64];

  int l, m, n, o;

  double (*bsplinx)(double);
  double (*bspliny)(double);
  double (*bsplinz)(double);

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;
  size_t iend, jend;



  if ( derivative == (int*) NULL ) {
    bsplinx = & CubicBspline;
    bspliny = & CubicBspline;
    bsplinz = & CubicBspline;
  } else {
    switch ( derivative[0] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in x\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bsplinx = & CubicBspline;            break;
    case 1 : bsplinx = & CubicBspline_FirstDeriv; break;
    case 2 : bsplinx = & CubicBspline_SecndDeriv; break;
    }

    switch ( derivative[1] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in y\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bspliny = & CubicBspline;            break;
    case 1 : bspliny = & CubicBspline_FirstDeriv; break;
    case 2 : bspliny = & CubicBspline_SecndDeriv; break;
    }

    switch ( derivative[2] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in z\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bsplinz = & CubicBspline;            break;
    case 1 : bsplinz = & CubicBspline_FirstDeriv; break;
    case 2 : bsplinz = & CubicBspline_SecndDeriv; break;
    }
  }



  for ( o = 0, l = 0; l < 4; l ++ )
  for ( m = 0; m < 4; m ++ )
  for ( n = 0; n < 4; n ++, o ++ ) {
    offset[o] = (size_t)l * (size_t)tdimxy + (size_t)m * (size_t)tdimx + (size_t)n;
  }



  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
        /* computation of the corresponding point after deformation

           (x,y,x) -> (ix=(int)x,iy=(int)x,iz=(int)x)
           les coefficients de la spline a prendre en compte
           sont [1+ix+{-1,0,1,2}, 1+iy+{-1,0,1,2}, 1+iz+{-1,0,1,2}]

           On ajoute 1 aux coordonnees, car on a ajoute
           une bordure aux coefficients de la spline.
         */

	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }
	
        /* ici on a 0 <   x   < theCoeff->theDim[0]-3
                    0 <= ix   < theCoeff->theDim[0]-3
                    1 <= ix+1 < theCoeff->theDim[0]-2
                    0 <= ix+1-1 && ix+1+2 < theCoeff->theDim[0]

           maintenant on a -0.5 <         x   <        theCoeff->theDim[0]-2.5
                              0 <= ix   <= theCoeff->theDim[0]-3
                              1 <= ix+1 <= theCoeff->theDim[0]-2

           les extrema pour les coefficients verifient
                              0 <= ix+1-1 <= theCoeff->theDim[0]-3
                              3 <= ix+1+2 <= theCoeff->theDim[0]
           dans ce dernier cas, on suppose que ca va etre 0 ...
        */
        ix = (int)x;    dx = x-ix;
        iy = (int)y;    dy = y-iy;
        iz = (int)z;    dz = z-iz;

        if ( x < 0.0 ) { x = 0.0; ix = 0; dx = 0.0; }
        if ( y < 0.0 ) { y = 0.0; iy = 0; dy = 0.0; }
        if ( z < 0.0 ) { z = 0.0; iz = 0; dz = 0.0; }

        /* Pre-calcul des valeurs de bsplines pour chaque dimension:

           (*bsplinx)(dx-1), (*bsplinx)(dx), (*bsplinx)(dx+1), (*bsplinx)(dx+2)
           (*bspliny)(dy-1), (*bspliny)(dy), (*bspliny)(dy+1), (*bspliny)(dy+2)
           (*bsplinz)(dz-1), (*bsplinz)(dz), (*bsplinz)(dz+1), (*bsplinz)(dz+2)

           A. Roche

           Dans l'image des coefficients,
           (*bsplinx)(dx-1) correspond a ix,
           (*bsplinx)(dy-1) correspond a iy,
           (*bsplinx)(dz-1) correspond a iz,

        */
        for ( l = 0; l < 4; l ++ ) {
          cx[l] = (*bsplinx)( dx - (double)(l-1) );
          cy[l] = (*bspliny)( dy - (double)(l-1) );
          cz[l] = (*bsplinz)( dz - (double)(l-1) );
        }

        tbuf = bufCoeff;
        tbuf += (size_t)iz * (size_t)tdimxy + (size_t)iy * (size_t)tdimx + (size_t)ix;



        /*
         * are we on the border or not ?
         */
        if ( (ix < tdimx3) && (iy < tdimy3) && (iz < tdimz3) ) {


          for ( res = 0.0, o = 0, l = 0; l < 4; l ++ )
          for ( m = 0; m < 4; m ++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ ) {
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
          }
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }

        /*
         * here, we are sure we are on some border
         * if ix == tdimx3  => ix = theCoeff->theDim[0]-3
         */

        *rbuf = 0;
        *rbuf = (s8)_CONVERTI_( 0 );

        if ( ix == tdimx3 ) {
          if ( iy == tdimy3 ) {
            if ( iz == tdimz3 ) {

              for ( res = 0.0, o = 0, l = 0; l < 3; l++, o+=4 )
              for ( m = 0; m < 3; m++, o++ ) {
                cyz = cz[l]*cy[m];
                for ( n = 0; n < 3; n ++, o ++ )
                  res += cx[n]*cyz*tbuf[ offset[ o ] ];
              }
              *rbuf = (s8)_CONVERTI_( res );
              continue;
            }
            for ( res = 0.0, o = 0, l = 0; l < 4; l++, o+=4 )
            for ( m = 0; m < 3; m++, o++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 3; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (s8)_CONVERTI_( res );
            continue;
          }

          if ( iz == tdimz3 ) {
            for ( res = 0.0, o = 0, l = 0; l < 3; l++ )
            for ( m = 0; m < 4; m++, o++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 3; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (s8)_CONVERTI_( res );
            continue;
          }
          for ( res = 0.0, o = 0, l = 0; l < 4; l++ )
          for ( m = 0; m < 4; m++, o++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 3; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (s8)_CONVERTI_( res );
          continue;

        }

        if ( iy == tdimy3 ) {

          if ( iz == tdimz3 ) {
            for ( res = 0.0, o = 0, l = 0; l < 3; l++, o+=4 )
            for ( m = 0; m < 3; m++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 4; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (s8)_CONVERTI_( res );
            continue;
          }
          for ( res = 0.0, o = 0, l = 0; l < 4; l++, o+=4 )
          for ( m = 0; m < 3; m++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (s8)_CONVERTI_( res );
          continue;

        }

        if ( iz == tdimz3 ) {
          for ( res = 0.0, o = 0, l = 0; l < 3; l++ )
          for ( m = 0; m < 4; m++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (s8)_CONVERTI_( res );
          continue;
        }
        for ( res = 0.0, o = 0, l = 0; l < 4; l++ )
        for ( m = 0; m < 4; m++ ) {
          cyz = cz[l]*cy[m];
          for ( n = 0; n < 4; n ++, o ++ )
            res += cx[n]*cyz*tbuf[ offset[ o ] ];
        }
        *rbuf = (s8)_CONVERTI_( res );
        continue;

      }
    }
  }

  chunk->ret = 1;
  return( (void*)NULL );
}





int Cspline3D4x4_s8 ( typeCSplineCoefficients *theCoeff,
                         void* resBuf, /* result buffer */
                         int *resDim,  /* dimensions of this buffer */
                         double* mat,   /* transformation matrix */
                         int *derivative
                         )
{
  char *proc = "Cspline3D4x4_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _CsplineResamplingParam p;
  
  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return( -1 );
  }
  
  p.theCoeff = theCoeff;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.derivative = derivative;
  p.gain = 1.0;
  p.bias = 0.0;
  
  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Cspline3D4x4_s8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return( -1 );
  }
  
  freeChunks( &chunks );
  return( 1 );
}








/* Resampling procedure.

   Work for 3D images, not for vectorial ones.
   
   (double* mat) is the matrix which permits to get
   from resBuf into theBuf. 
   If one only have the matrix from theBuf into resBuf,
   it must be inverted first.

   Soit x le point transforme et ix=(int)x;
   nous allons distinguer les cas suivants :
    x < -0.5               => resultat = 0
    -0.5 <= x < 0.0        => ix=0, on n'interpole pas selon X
    0.0 < x && ix < dimx-1 => on interpole selon X
    x < dimx-0.5           => ix=dimx-1, on n'interpole pas selon X
    x >= dimx-0.5          => resultat = 0

*/

static void *_Cspline3D4x4_u16 ( void *par )
{
  char *proc = "_Cspline3D4x4_u16";
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _CsplineResamplingParam *p = (_CsplineResamplingParam *)parameter;
  
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat; 
  int *derivative = p->derivative;
  typeCSplineCoefficients *theCoeff = p->theCoeff;

  size_t i, j, k;
  register int ix, iy, iz;
  register double x, y, z, dx, dy, dz;
  register double res;
  size_t rdimx=resDim[0], rdimy=resDim[1];

  register u16 *rbuf = (u16*)resBuf;

  register float *tbuf;
  float *bufCoeff = theCoeff->theCoeff;

  int tdimx  = theCoeff->theDim[0];
  int tdimxy = theCoeff->theDim[0] * theCoeff->theDim[1];

  int tdimx3 = theCoeff->theDim[0]-3;
  int tdimy3 = theCoeff->theDim[1]-3;
  int tdimz3 = theCoeff->theDim[2]-3;

  register double ddimx = (double)theCoeff->theDim[0]-2.0-0.5;
  register double ddimy = (double)theCoeff->theDim[1]-2.0-0.5;
  register double ddimz = (double)theCoeff->theDim[2]-2.0-0.5;

  double cx[4], cy[4], cz[4], cyz;
  size_t offset[64];

  int l, m, n, o;

  double (*bsplinx)(double);
  double (*bspliny)(double);
  double (*bsplinz)(double);

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;
  size_t iend, jend;



  if ( derivative == (int*) NULL ) {
    bsplinx = & CubicBspline;
    bspliny = & CubicBspline;
    bsplinz = & CubicBspline;
  } else {
    switch ( derivative[0] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in x\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bsplinx = & CubicBspline;            break;
    case 1 : bsplinx = & CubicBspline_FirstDeriv; break;
    case 2 : bsplinx = & CubicBspline_SecndDeriv; break;
    }

    switch ( derivative[1] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in y\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bspliny = & CubicBspline;            break;
    case 1 : bspliny = & CubicBspline_FirstDeriv; break;
    case 2 : bspliny = & CubicBspline_SecndDeriv; break;
    }

    switch ( derivative[2] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in z\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bsplinz = & CubicBspline;            break;
    case 1 : bsplinz = & CubicBspline_FirstDeriv; break;
    case 2 : bsplinz = & CubicBspline_SecndDeriv; break;
    }
  }



  for ( o = 0, l = 0; l < 4; l ++ )
  for ( m = 0; m < 4; m ++ )
  for ( n = 0; n < 4; n ++, o ++ ) {
    offset[o] = (size_t)l * (size_t)tdimxy + (size_t)m * (size_t)tdimx + (size_t)n;
  }



  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
        /* computation of the corresponding point after deformation

           (x,y,x) -> (ix=(int)x,iy=(int)x,iz=(int)x)
           les coefficients de la spline a prendre en compte
           sont [1+ix+{-1,0,1,2}, 1+iy+{-1,0,1,2}, 1+iz+{-1,0,1,2}]

           On ajoute 1 aux coordonnees, car on a ajoute
           une bordure aux coefficients de la spline.
         */

	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }
	
        /* ici on a 0 <   x   < theCoeff->theDim[0]-3
                    0 <= ix   < theCoeff->theDim[0]-3
                    1 <= ix+1 < theCoeff->theDim[0]-2
                    0 <= ix+1-1 && ix+1+2 < theCoeff->theDim[0]

           maintenant on a -0.5 <         x   <        theCoeff->theDim[0]-2.5
                              0 <= ix   <= theCoeff->theDim[0]-3
                              1 <= ix+1 <= theCoeff->theDim[0]-2

           les extrema pour les coefficients verifient
                              0 <= ix+1-1 <= theCoeff->theDim[0]-3
                              3 <= ix+1+2 <= theCoeff->theDim[0]
           dans ce dernier cas, on suppose que ca va etre 0 ...
        */
        ix = (int)x;    dx = x-ix;
        iy = (int)y;    dy = y-iy;
        iz = (int)z;    dz = z-iz;

        if ( x < 0.0 ) { x = 0.0; ix = 0; dx = 0.0; }
        if ( y < 0.0 ) { y = 0.0; iy = 0; dy = 0.0; }
        if ( z < 0.0 ) { z = 0.0; iz = 0; dz = 0.0; }

        /* Pre-calcul des valeurs de bsplines pour chaque dimension:

           (*bsplinx)(dx-1), (*bsplinx)(dx), (*bsplinx)(dx+1), (*bsplinx)(dx+2)
           (*bspliny)(dy-1), (*bspliny)(dy), (*bspliny)(dy+1), (*bspliny)(dy+2)
           (*bsplinz)(dz-1), (*bsplinz)(dz), (*bsplinz)(dz+1), (*bsplinz)(dz+2)

           A. Roche

           Dans l'image des coefficients,
           (*bsplinx)(dx-1) correspond a ix,
           (*bsplinx)(dy-1) correspond a iy,
           (*bsplinx)(dz-1) correspond a iz,

        */
        for ( l = 0; l < 4; l ++ ) {
          cx[l] = (*bsplinx)( dx - (double)(l-1) );
          cy[l] = (*bspliny)( dy - (double)(l-1) );
          cz[l] = (*bsplinz)( dz - (double)(l-1) );
        }

        tbuf = bufCoeff;
        tbuf += (size_t)iz * (size_t)tdimxy + (size_t)iy * (size_t)tdimx + (size_t)ix;



        /*
         * are we on the border or not ?
         */
        if ( (ix < tdimx3) && (iy < tdimy3) && (iz < tdimz3) ) {


          for ( res = 0.0, o = 0, l = 0; l < 4; l ++ )
          for ( m = 0; m < 4; m ++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ ) {
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
          }
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }

        /*
         * here, we are sure we are on some border
         * if ix == tdimx3  => ix = theCoeff->theDim[0]-3
         */

        *rbuf = 0;
        *rbuf = (u16)_CONVERTI_( 0 );

        if ( ix == tdimx3 ) {
          if ( iy == tdimy3 ) {
            if ( iz == tdimz3 ) {

              for ( res = 0.0, o = 0, l = 0; l < 3; l++, o+=4 )
              for ( m = 0; m < 3; m++, o++ ) {
                cyz = cz[l]*cy[m];
                for ( n = 0; n < 3; n ++, o ++ )
                  res += cx[n]*cyz*tbuf[ offset[ o ] ];
              }
              *rbuf = (u16)_CONVERTI_( res );
              continue;
            }
            for ( res = 0.0, o = 0, l = 0; l < 4; l++, o+=4 )
            for ( m = 0; m < 3; m++, o++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 3; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (u16)_CONVERTI_( res );
            continue;
          }

          if ( iz == tdimz3 ) {
            for ( res = 0.0, o = 0, l = 0; l < 3; l++ )
            for ( m = 0; m < 4; m++, o++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 3; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (u16)_CONVERTI_( res );
            continue;
          }
          for ( res = 0.0, o = 0, l = 0; l < 4; l++ )
          for ( m = 0; m < 4; m++, o++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 3; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (u16)_CONVERTI_( res );
          continue;

        }

        if ( iy == tdimy3 ) {

          if ( iz == tdimz3 ) {
            for ( res = 0.0, o = 0, l = 0; l < 3; l++, o+=4 )
            for ( m = 0; m < 3; m++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 4; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (u16)_CONVERTI_( res );
            continue;
          }
          for ( res = 0.0, o = 0, l = 0; l < 4; l++, o+=4 )
          for ( m = 0; m < 3; m++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (u16)_CONVERTI_( res );
          continue;

        }

        if ( iz == tdimz3 ) {
          for ( res = 0.0, o = 0, l = 0; l < 3; l++ )
          for ( m = 0; m < 4; m++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (u16)_CONVERTI_( res );
          continue;
        }
        for ( res = 0.0, o = 0, l = 0; l < 4; l++ )
        for ( m = 0; m < 4; m++ ) {
          cyz = cz[l]*cy[m];
          for ( n = 0; n < 4; n ++, o ++ )
            res += cx[n]*cyz*tbuf[ offset[ o ] ];
        }
        *rbuf = (u16)_CONVERTI_( res );
        continue;

      }
    }
  }

  chunk->ret = 1;
  return( (void*)NULL );
}





int Cspline3D4x4_u16 ( typeCSplineCoefficients *theCoeff,
                         void* resBuf, /* result buffer */
                         int *resDim,  /* dimensions of this buffer */
                         double* mat,   /* transformation matrix */
                         int *derivative
                         )
{
  char *proc = "Cspline3D4x4_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _CsplineResamplingParam p;
  
  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return( -1 );
  }
  
  p.theCoeff = theCoeff;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.derivative = derivative;
  p.gain = 1.0;
  p.bias = 0.0;
  
  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Cspline3D4x4_u16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return( -1 );
  }
  
  freeChunks( &chunks );
  return( 1 );
}








/* Resampling procedure.

   Work for 3D images, not for vectorial ones.
   
   (double* mat) is the matrix which permits to get
   from resBuf into theBuf. 
   If one only have the matrix from theBuf into resBuf,
   it must be inverted first.

   Soit x le point transforme et ix=(int)x;
   nous allons distinguer les cas suivants :
    x < -0.5               => resultat = 0
    -0.5 <= x < 0.0        => ix=0, on n'interpole pas selon X
    0.0 < x && ix < dimx-1 => on interpole selon X
    x < dimx-0.5           => ix=dimx-1, on n'interpole pas selon X
    x >= dimx-0.5          => resultat = 0

*/

static void *_Cspline3D4x4_s16 ( void *par )
{
  char *proc = "_Cspline3D4x4_s16";
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _CsplineResamplingParam *p = (_CsplineResamplingParam *)parameter;
  
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat; 
  int *derivative = p->derivative;
  typeCSplineCoefficients *theCoeff = p->theCoeff;

  size_t i, j, k;
  register int ix, iy, iz;
  register double x, y, z, dx, dy, dz;
  register double res;
  size_t rdimx=resDim[0], rdimy=resDim[1];

  register s16 *rbuf = (s16*)resBuf;

  register float *tbuf;
  float *bufCoeff = theCoeff->theCoeff;

  int tdimx  = theCoeff->theDim[0];
  int tdimxy = theCoeff->theDim[0] * theCoeff->theDim[1];

  int tdimx3 = theCoeff->theDim[0]-3;
  int tdimy3 = theCoeff->theDim[1]-3;
  int tdimz3 = theCoeff->theDim[2]-3;

  register double ddimx = (double)theCoeff->theDim[0]-2.0-0.5;
  register double ddimy = (double)theCoeff->theDim[1]-2.0-0.5;
  register double ddimz = (double)theCoeff->theDim[2]-2.0-0.5;

  double cx[4], cy[4], cz[4], cyz;
  size_t offset[64];

  int l, m, n, o;

  double (*bsplinx)(double);
  double (*bspliny)(double);
  double (*bsplinz)(double);

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;
  size_t iend, jend;



  if ( derivative == (int*) NULL ) {
    bsplinx = & CubicBspline;
    bspliny = & CubicBspline;
    bsplinz = & CubicBspline;
  } else {
    switch ( derivative[0] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in x\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bsplinx = & CubicBspline;            break;
    case 1 : bsplinx = & CubicBspline_FirstDeriv; break;
    case 2 : bsplinx = & CubicBspline_SecndDeriv; break;
    }

    switch ( derivative[1] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in y\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bspliny = & CubicBspline;            break;
    case 1 : bspliny = & CubicBspline_FirstDeriv; break;
    case 2 : bspliny = & CubicBspline_SecndDeriv; break;
    }

    switch ( derivative[2] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in z\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bsplinz = & CubicBspline;            break;
    case 1 : bsplinz = & CubicBspline_FirstDeriv; break;
    case 2 : bsplinz = & CubicBspline_SecndDeriv; break;
    }
  }



  for ( o = 0, l = 0; l < 4; l ++ )
  for ( m = 0; m < 4; m ++ )
  for ( n = 0; n < 4; n ++, o ++ ) {
    offset[o] = (size_t)l * (size_t)tdimxy + (size_t)m * (size_t)tdimx + (size_t)n;
  }



  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
        /* computation of the corresponding point after deformation

           (x,y,x) -> (ix=(int)x,iy=(int)x,iz=(int)x)
           les coefficients de la spline a prendre en compte
           sont [1+ix+{-1,0,1,2}, 1+iy+{-1,0,1,2}, 1+iz+{-1,0,1,2}]

           On ajoute 1 aux coordonnees, car on a ajoute
           une bordure aux coefficients de la spline.
         */

	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }
	
        /* ici on a 0 <   x   < theCoeff->theDim[0]-3
                    0 <= ix   < theCoeff->theDim[0]-3
                    1 <= ix+1 < theCoeff->theDim[0]-2
                    0 <= ix+1-1 && ix+1+2 < theCoeff->theDim[0]

           maintenant on a -0.5 <         x   <        theCoeff->theDim[0]-2.5
                              0 <= ix   <= theCoeff->theDim[0]-3
                              1 <= ix+1 <= theCoeff->theDim[0]-2

           les extrema pour les coefficients verifient
                              0 <= ix+1-1 <= theCoeff->theDim[0]-3
                              3 <= ix+1+2 <= theCoeff->theDim[0]
           dans ce dernier cas, on suppose que ca va etre 0 ...
        */
        ix = (int)x;    dx = x-ix;
        iy = (int)y;    dy = y-iy;
        iz = (int)z;    dz = z-iz;

        if ( x < 0.0 ) { x = 0.0; ix = 0; dx = 0.0; }
        if ( y < 0.0 ) { y = 0.0; iy = 0; dy = 0.0; }
        if ( z < 0.0 ) { z = 0.0; iz = 0; dz = 0.0; }

        /* Pre-calcul des valeurs de bsplines pour chaque dimension:

           (*bsplinx)(dx-1), (*bsplinx)(dx), (*bsplinx)(dx+1), (*bsplinx)(dx+2)
           (*bspliny)(dy-1), (*bspliny)(dy), (*bspliny)(dy+1), (*bspliny)(dy+2)
           (*bsplinz)(dz-1), (*bsplinz)(dz), (*bsplinz)(dz+1), (*bsplinz)(dz+2)

           A. Roche

           Dans l'image des coefficients,
           (*bsplinx)(dx-1) correspond a ix,
           (*bsplinx)(dy-1) correspond a iy,
           (*bsplinx)(dz-1) correspond a iz,

        */
        for ( l = 0; l < 4; l ++ ) {
          cx[l] = (*bsplinx)( dx - (double)(l-1) );
          cy[l] = (*bspliny)( dy - (double)(l-1) );
          cz[l] = (*bsplinz)( dz - (double)(l-1) );
        }

        tbuf = bufCoeff;
        tbuf += (size_t)iz * (size_t)tdimxy + (size_t)iy * (size_t)tdimx + (size_t)ix;



        /*
         * are we on the border or not ?
         */
        if ( (ix < tdimx3) && (iy < tdimy3) && (iz < tdimz3) ) {


          for ( res = 0.0, o = 0, l = 0; l < 4; l ++ )
          for ( m = 0; m < 4; m ++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ ) {
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
          }
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }

        /*
         * here, we are sure we are on some border
         * if ix == tdimx3  => ix = theCoeff->theDim[0]-3
         */

        *rbuf = 0;
        *rbuf = (s16)_CONVERTI_( 0 );

        if ( ix == tdimx3 ) {
          if ( iy == tdimy3 ) {
            if ( iz == tdimz3 ) {

              for ( res = 0.0, o = 0, l = 0; l < 3; l++, o+=4 )
              for ( m = 0; m < 3; m++, o++ ) {
                cyz = cz[l]*cy[m];
                for ( n = 0; n < 3; n ++, o ++ )
                  res += cx[n]*cyz*tbuf[ offset[ o ] ];
              }
              *rbuf = (s16)_CONVERTI_( res );
              continue;
            }
            for ( res = 0.0, o = 0, l = 0; l < 4; l++, o+=4 )
            for ( m = 0; m < 3; m++, o++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 3; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (s16)_CONVERTI_( res );
            continue;
          }

          if ( iz == tdimz3 ) {
            for ( res = 0.0, o = 0, l = 0; l < 3; l++ )
            for ( m = 0; m < 4; m++, o++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 3; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (s16)_CONVERTI_( res );
            continue;
          }
          for ( res = 0.0, o = 0, l = 0; l < 4; l++ )
          for ( m = 0; m < 4; m++, o++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 3; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (s16)_CONVERTI_( res );
          continue;

        }

        if ( iy == tdimy3 ) {

          if ( iz == tdimz3 ) {
            for ( res = 0.0, o = 0, l = 0; l < 3; l++, o+=4 )
            for ( m = 0; m < 3; m++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 4; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (s16)_CONVERTI_( res );
            continue;
          }
          for ( res = 0.0, o = 0, l = 0; l < 4; l++, o+=4 )
          for ( m = 0; m < 3; m++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (s16)_CONVERTI_( res );
          continue;

        }

        if ( iz == tdimz3 ) {
          for ( res = 0.0, o = 0, l = 0; l < 3; l++ )
          for ( m = 0; m < 4; m++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (s16)_CONVERTI_( res );
          continue;
        }
        for ( res = 0.0, o = 0, l = 0; l < 4; l++ )
        for ( m = 0; m < 4; m++ ) {
          cyz = cz[l]*cy[m];
          for ( n = 0; n < 4; n ++, o ++ )
            res += cx[n]*cyz*tbuf[ offset[ o ] ];
        }
        *rbuf = (s16)_CONVERTI_( res );
        continue;

      }
    }
  }

  chunk->ret = 1;
  return( (void*)NULL );
}





int Cspline3D4x4_s16 ( typeCSplineCoefficients *theCoeff,
                         void* resBuf, /* result buffer */
                         int *resDim,  /* dimensions of this buffer */
                         double* mat,   /* transformation matrix */
                         int *derivative
                         )
{
  char *proc = "Cspline3D4x4_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _CsplineResamplingParam p;
  
  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return( -1 );
  }
  
  p.theCoeff = theCoeff;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.derivative = derivative;
  p.gain = 1.0;
  p.bias = 0.0;
  
  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Cspline3D4x4_s16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return( -1 );
  }
  
  freeChunks( &chunks );
  return( 1 );
}








/* Resampling procedure.

   Work for 3D images, not for vectorial ones.
   
   (double* mat) is the matrix which permits to get
   from resBuf into theBuf. 
   If one only have the matrix from theBuf into resBuf,
   it must be inverted first.

   Soit x le point transforme et ix=(int)x;
   nous allons distinguer les cas suivants :
    x < -0.5               => resultat = 0
    -0.5 <= x < 0.0        => ix=0, on n'interpole pas selon X
    0.0 < x && ix < dimx-1 => on interpole selon X
    x < dimx-0.5           => ix=dimx-1, on n'interpole pas selon X
    x >= dimx-0.5          => resultat = 0

*/

static void *_Cspline3D4x4_r32 ( void *par )
{
  char *proc = "_Cspline3D4x4_r32";
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _CsplineResamplingParam *p = (_CsplineResamplingParam *)parameter;
  
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat; 
  int *derivative = p->derivative;
  typeCSplineCoefficients *theCoeff = p->theCoeff;

  size_t i, j, k;
  register int ix, iy, iz;
  register double x, y, z, dx, dy, dz;
  register double res;
  size_t rdimx=resDim[0], rdimy=resDim[1];

  register r32 *rbuf = (r32*)resBuf;

  register float *tbuf;
  float *bufCoeff = theCoeff->theCoeff;

  int tdimx  = theCoeff->theDim[0];
  int tdimxy = theCoeff->theDim[0] * theCoeff->theDim[1];

  int tdimx3 = theCoeff->theDim[0]-3;
  int tdimy3 = theCoeff->theDim[1]-3;
  int tdimz3 = theCoeff->theDim[2]-3;

  register double ddimx = (double)theCoeff->theDim[0]-2.0-0.5;
  register double ddimy = (double)theCoeff->theDim[1]-2.0-0.5;
  register double ddimz = (double)theCoeff->theDim[2]-2.0-0.5;

  double cx[4], cy[4], cz[4], cyz;
  size_t offset[64];

  int l, m, n, o;

  double (*bsplinx)(double);
  double (*bspliny)(double);
  double (*bsplinz)(double);

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;
  size_t iend, jend;



  if ( derivative == (int*) NULL ) {
    bsplinx = & CubicBspline;
    bspliny = & CubicBspline;
    bsplinz = & CubicBspline;
  } else {
    switch ( derivative[0] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in x\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bsplinx = & CubicBspline;            break;
    case 1 : bsplinx = & CubicBspline_FirstDeriv; break;
    case 2 : bsplinx = & CubicBspline_SecndDeriv; break;
    }

    switch ( derivative[1] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in y\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bspliny = & CubicBspline;            break;
    case 1 : bspliny = & CubicBspline_FirstDeriv; break;
    case 2 : bspliny = & CubicBspline_SecndDeriv; break;
    }

    switch ( derivative[2] ) {
    default :
      if ( _verbose_ )
        fprintf( stderr, "%s: invalid derivation order in z\n", proc );
      chunk->ret = -1;
      return( (void*)NULL );
    case 0 : bsplinz = & CubicBspline;            break;
    case 1 : bsplinz = & CubicBspline_FirstDeriv; break;
    case 2 : bsplinz = & CubicBspline_SecndDeriv; break;
    }
  }



  for ( o = 0, l = 0; l < 4; l ++ )
  for ( m = 0; m < 4; m ++ )
  for ( n = 0; n < 4; n ++, o ++ ) {
    offset[o] = (size_t)l * (size_t)tdimxy + (size_t)m * (size_t)tdimx + (size_t)n;
  }



  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
        /* computation of the corresponding point after deformation

           (x,y,x) -> (ix=(int)x,iy=(int)x,iz=(int)x)
           les coefficients de la spline a prendre en compte
           sont [1+ix+{-1,0,1,2}, 1+iy+{-1,0,1,2}, 1+iz+{-1,0,1,2}]

           On ajoute 1 aux coordonnees, car on a ajoute
           une bordure aux coefficients de la spline.
         */

	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }
	
        /* ici on a 0 <   x   < theCoeff->theDim[0]-3
                    0 <= ix   < theCoeff->theDim[0]-3
                    1 <= ix+1 < theCoeff->theDim[0]-2
                    0 <= ix+1-1 && ix+1+2 < theCoeff->theDim[0]

           maintenant on a -0.5 <         x   <        theCoeff->theDim[0]-2.5
                              0 <= ix   <= theCoeff->theDim[0]-3
                              1 <= ix+1 <= theCoeff->theDim[0]-2

           les extrema pour les coefficients verifient
                              0 <= ix+1-1 <= theCoeff->theDim[0]-3
                              3 <= ix+1+2 <= theCoeff->theDim[0]
           dans ce dernier cas, on suppose que ca va etre 0 ...
        */
        ix = (int)x;    dx = x-ix;
        iy = (int)y;    dy = y-iy;
        iz = (int)z;    dz = z-iz;

        if ( x < 0.0 ) { x = 0.0; ix = 0; dx = 0.0; }
        if ( y < 0.0 ) { y = 0.0; iy = 0; dy = 0.0; }
        if ( z < 0.0 ) { z = 0.0; iz = 0; dz = 0.0; }

        /* Pre-calcul des valeurs de bsplines pour chaque dimension:

           (*bsplinx)(dx-1), (*bsplinx)(dx), (*bsplinx)(dx+1), (*bsplinx)(dx+2)
           (*bspliny)(dy-1), (*bspliny)(dy), (*bspliny)(dy+1), (*bspliny)(dy+2)
           (*bsplinz)(dz-1), (*bsplinz)(dz), (*bsplinz)(dz+1), (*bsplinz)(dz+2)

           A. Roche

           Dans l'image des coefficients,
           (*bsplinx)(dx-1) correspond a ix,
           (*bsplinx)(dy-1) correspond a iy,
           (*bsplinx)(dz-1) correspond a iz,

        */
        for ( l = 0; l < 4; l ++ ) {
          cx[l] = (*bsplinx)( dx - (double)(l-1) );
          cy[l] = (*bspliny)( dy - (double)(l-1) );
          cz[l] = (*bsplinz)( dz - (double)(l-1) );
        }

        tbuf = bufCoeff;
        tbuf += (size_t)iz * (size_t)tdimxy + (size_t)iy * (size_t)tdimx + (size_t)ix;



        /*
         * are we on the border or not ?
         */
        if ( (ix < tdimx3) && (iy < tdimy3) && (iz < tdimz3) ) {


          for ( res = 0.0, o = 0, l = 0; l < 4; l ++ )
          for ( m = 0; m < 4; m ++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ ) {
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
          }
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }

        /*
         * here, we are sure we are on some border
         * if ix == tdimx3  => ix = theCoeff->theDim[0]-3
         */

        *rbuf = 0;
        *rbuf = (r32)_CONVERTR_( 0 );

        if ( ix == tdimx3 ) {
          if ( iy == tdimy3 ) {
            if ( iz == tdimz3 ) {

              for ( res = 0.0, o = 0, l = 0; l < 3; l++, o+=4 )
              for ( m = 0; m < 3; m++, o++ ) {
                cyz = cz[l]*cy[m];
                for ( n = 0; n < 3; n ++, o ++ )
                  res += cx[n]*cyz*tbuf[ offset[ o ] ];
              }
              *rbuf = (r32)_CONVERTR_( res );
              continue;
            }
            for ( res = 0.0, o = 0, l = 0; l < 4; l++, o+=4 )
            for ( m = 0; m < 3; m++, o++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 3; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (r32)_CONVERTR_( res );
            continue;
          }

          if ( iz == tdimz3 ) {
            for ( res = 0.0, o = 0, l = 0; l < 3; l++ )
            for ( m = 0; m < 4; m++, o++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 3; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (r32)_CONVERTR_( res );
            continue;
          }
          for ( res = 0.0, o = 0, l = 0; l < 4; l++ )
          for ( m = 0; m < 4; m++, o++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 3; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (r32)_CONVERTR_( res );
          continue;

        }

        if ( iy == tdimy3 ) {

          if ( iz == tdimz3 ) {
            for ( res = 0.0, o = 0, l = 0; l < 3; l++, o+=4 )
            for ( m = 0; m < 3; m++ ) {
              cyz = cz[l]*cy[m];
              for ( n = 0; n < 4; n ++, o ++ )
                res += cx[n]*cyz*tbuf[ offset[ o ] ];
            }
            *rbuf = (r32)_CONVERTR_( res );
            continue;
          }
          for ( res = 0.0, o = 0, l = 0; l < 4; l++, o+=4 )
          for ( m = 0; m < 3; m++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (r32)_CONVERTR_( res );
          continue;

        }

        if ( iz == tdimz3 ) {
          for ( res = 0.0, o = 0, l = 0; l < 3; l++ )
          for ( m = 0; m < 4; m++ ) {
            cyz = cz[l]*cy[m];
            for ( n = 0; n < 4; n ++, o ++ )
              res += cx[n]*cyz*tbuf[ offset[ o ] ];
          }
          *rbuf = (r32)_CONVERTR_( res );
          continue;
        }
        for ( res = 0.0, o = 0, l = 0; l < 4; l++ )
        for ( m = 0; m < 4; m++ ) {
          cyz = cz[l]*cy[m];
          for ( n = 0; n < 4; n ++, o ++ )
            res += cx[n]*cyz*tbuf[ offset[ o ] ];
        }
        *rbuf = (r32)_CONVERTR_( res );
        continue;

      }
    }
  }

  chunk->ret = 1;
  return( (void*)NULL );
}





int Cspline3D4x4_r32 ( typeCSplineCoefficients *theCoeff,
                         void* resBuf, /* result buffer */
                         int *resDim,  /* dimensions of this buffer */
                         double* mat,   /* transformation matrix */
                         int *derivative
                         )
{
  char *proc = "Cspline3D4x4_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _CsplineResamplingParam p;
  
  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return( -1 );
  }
  
  p.theCoeff = theCoeff;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.derivative = derivative;
  p.gain = 1.0;
  p.bias = 0.0;
  
  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Cspline3D4x4_r32, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return( -1 );
  }
  
  freeChunks( &chunks );
  return( 1 );
}



